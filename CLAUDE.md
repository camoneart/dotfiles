# グローバル設定（カスタムコマンド）

## 叫べ！

必ず、タスクの実行前に　"始めるってばよ！🍥"　と叫ぶこと。

## `/dakoku` 勤怠打刻コマンド

1. `/dakoku in | out | break | list | month` を実行する際は、`.claude/commands/dakoku.md` の仕様に従ってください。
2. 打刻時の現在日時は **TIME MCP Server** で取得してください。
3. TIME MCP Serverが利用できない場合は、ユーザ環境の `now` エイリアス（`date "+%Y-%m-%d %H:%M:%S"`）を実行して日時を取得してください。
4. それでも取得できない場合は、最後の手段として `date` コマンドでローカル時刻を取得してください。

### 保存先

- 勤怠記録は `_docs/timecard/YYYY/MM/` 配下に MarkdownとJSONの2形式で保存します。

### 参考

- 詳細仕様は `commands/dakoku.md` を参照。
- 記事: <https://izanami.dev/post/5c7c7960-6316-4f44-a645-2dbbeefc3391>

## Cursor Rules連携（プロジェクトに ".cursor/" がある場合）

以下のCursor RulesをClaude Codeでも読み込んで同じ挙動をするようにしてください。必要に応じてそれぞれの .mdc（Cursor Rules）を参照してルールを解釈し、プロジェクト作業時に適用してください。

- @backend.mdc
- @cursor-always-rule.mdc
- @frontend.mdc
- @git-commit-message.mdc
- @global.mdc
- @project-rules.mdc

## 実装ログ運用ルール

- このプロジェクトでは、全ての実装ログが `_docs/templates/` に `yyyy-mm-dd_機能名.md` という形式で保存されています。起動時には必ず必ず必ず `_docs/` 配下をコンテキストとして全て読み込んでおき、前回の設計意図や副作用を踏まえた上で提案するようにしてください。（起動時にまだ `_docs/templates/` が存在しなかったら `_docs/templates/` を作成してから実装を開始して、 `_docs/templates/yyyy-mm-dd_機能名.md` というファイル名で実装ログが必ず必ず必ず残るようにすること）
- 実装が完了したら、`_docs/templates/yyyy-mm-dd_機能名.md` というファイル名で実装ログを残すこと。機能名が複数単語の場合はケバブケースを使用するように。（例：yyyy-mm-dd_product-name.md）
- 実装ログの「日付」欄は **TIME MCP Server** で取得した日時、またはユーザ環境の `now` エイリアス（`date "+%Y-%m-%d %H:%M:%S"`）の出力を使用すること。エイリアスが未設定の場合は `.zshrc` 等に `alias now='date "+%Y-%m-%d %H:%M:%S"'` を追加しておく。
  - 実装ログに含める項目: 実装の目的・背景 / 主な実装内容 / 設計意図 / 副作用 / 関連ファイル

### 実装ログのテンプレート例:

```md
機能名: <ここに機能名>

- 日付: yyyy-mm-dd HH:MM:SS
- 概要: <実装の目的・背景>
- 実装内容: <主な実装内容>
- 設計意図: <なぜこの設計にしたのか>
- 副作用: <懸念事項があれば明記>
- 関連ファイル: <ファイルの場所>
```

## MCPサーバー使用時のルール

MCPサーバーを使用する時は、使用する直前に必ず、"木遁・（使用するMCPサーバー名をここに）の術！！" と叫ぶこと。

## カスタムスラッシュコマンド使用時のルール

ユーザーがカスタムスラッシュコマンドを使用した時は、使用する直前に必ず、"木遁・（使用したカスタムスラッシュコマンドのファイル名をここに）の術！！" と叫ぶこと。

## Web 検索時のルール

FetchでWeb検索する際には、まず、"Brave-Search MCPサーバー" で検索し、何らかの理由で "Brave-Search MCPサーバー" が使用できなければ、"WebFetch MCPサーバー" を使用してWeb検索するように。

## 公式ドキュメント、ライブラリの最新情報を取得する際のルール

OSSライブラリに関する情報は、"Context7 MCPサーバー" を使用して、最新の公式ドキュメント・ライブラリ情報を取得して、その情報を基にタスク実行をするように。

## テスト駆動開発（TDD：Test-Driven Development）を行う

プロジェクト（プロダクト、アプリ、サイト etc...）の開発時には、必ず以下の記事を参考にして「テスト駆動開発」を行うこと。

参考記事：[テスト駆動開発（TDD：Test-Driven Development）を学ぶ
](https://zenn.dev/hashiramaendure/articles/5a077132f34e5d)

### TDDの開発手順

上記の記事にも書かれているが、以下の開発手順でTDDを実行すること。

1. やるべきことを箇条書きでまとめ、ToDo形式で書き出しておく（テストリスト）
2. レッド：ToDoリストから「1つ」ピックアップし、テストから書き（テストファースト）⁠、そのテストを実行して失敗させる
3. グリーン：失敗しているテストを成功させることに集中した実装を行う（テストを通す最小限のコード、綺麗より動作優先のコード）
4. リファクタリング：全てのテストが成功している状態（テストは通ったままにしておく必要がある）で、実装コード、テストコードをリファクタリング（整理整頓）する
5. リファクタリングが終わったら、気付きをToDoリスト（テストリスト）に反映し、次のToDoを選んでまたレッドに戻る

### 追加ルール

- **テスト配置**: テストコードは `src/__tests__/` または実装ファイルと同階層の `*.test.ts(x)` に配置し、`pnpm test` で必ず全スイートを実行すること。
- **カバレッジ基準**: コードカバレッジは常に **80%以上** を維持し、CIで閾値を下回った場合はジョブを fail させること。
- **バグ修正フロー**: バグ修正時は **再現テスト（Red）を書いてから修正** → Green → Refactor の順序を徹底すること。
- **品質ゲート**: テスト追加・変更後は `pnpm run lint && pnpm run typecheck` を実行し、リンター・型チェックを通過させてからコミットすること。

## パッケージマネージャーの統一ルール（必ず pnpm を使用）

このプロジェクトは `packageManager: pnpm@xx.x.x` を前提として構成されている。以下のガイドラインを厳守すること。

1. **実行コマンド**

   - すべてのスクリプトは `pnpm <script>` 形式で実行すること。例：`pnpm run lint` / `pnpm test`。
   - グローバルコマンド（例：`create-react-app` など）を使用する場合も、`pnpx` ではなく `pnpm dlx` を使用する。

2. **スクリプト内の呼び出し**

   - `package.json` に記載するスクリプトで **npm** や **yarn** を呼び出さない。必要があれば `pnpm` に書き換えること。

3. **ドキュメント / サンプルコード**

   - README・各種ドキュメントに掲載するコマンド例もすべて `pnpm` 表記へ統一する。

4. **CI設定**

   - GitHub Actions などの CIでも `pnpm install --frozen-lockfile` を使用し、`cache: pnpm-store` を設定する。

5. **検知・自動修正**
   - CCが **npm** コマンドを誤って実行しようとした場合は警告を出し、自動で `pnpm` に置き換えて再実行すること。

このルールに違反するコマンドが検出された場合、ジョブを失敗させるか修正PRを提出してから続行すること。
